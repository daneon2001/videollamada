<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Diagn√≥stico WebRTC / Socket.IO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Socket.IO cliente (misma versi√≥n que usas en app.js) -->
  <script src="https://cdn.socket.io/3.1.3/socket.io.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 900px;
      margin: 32px auto;
      padding: 24px;
      background: #020617;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      border: 1px solid #1f2937;
    }
    h1 {
      margin-top: 0;
      font-size: 1.8rem;
      color: #f97316;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.75rem;
      margin-left: 8px;
    }
    .badge-ok {
      background: #16a34a33;
      color: #bbf7d0;
      border: 1px solid #16a34a;
    }
    .badge-fail {
      background: #b91c1c33;
      color: #fecaca;
      border: 1px solid #dc2626;
    }
    .badge-pending {
      background: #0ea5e933;
      color: #bae6fd;
      border: 1px solid #0ea5e9;
    }
    button {
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 999px;
      padding: 10px 20px;
      font-size: 0.95rem;
      cursor: pointer;
      margin-right: 12px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .section {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid #1f2937;
    }
    .section h2 {
      font-size: 1rem;
      margin: 0 0 4px 0;
      color: #e5e7eb;
    }
    .status-line {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.9rem;
    }
    pre {
      background: #020617;
      border-radius: 8px;
      padding: 10px;
      font-size: 0.8rem;
      max-height: 260px;
      overflow: auto;
      border: 1px solid #1f2937;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .small {
      font-size: 0.8rem;
      color: #9ca3af;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>
      Diagn√≥stico Videollamada
      <span class="small">(WebRTC + Socket.IO)</span>
    </h1>
    <p class="small">
      Abre esta p√°gina desde el equipo del <strong>m√©dico</strong> y del <strong>paciente</strong>, ejecuta el diagn√≥stico
      y comp√°rame el resultado. 
    </p>

    <div style="margin: 12px 0 18px 0;">
      <button id="btnRun">‚ñ∂ Ejecutar diagn√≥stico</button>
      <button id="btnClear">üßπ Limpiar</button>
    </div>

    <!-- 1. Contexto del navegador -->
    <div class="section">
      <div class="status-line">
        <h2>Navegador / HTTPS</h2>
        <span id="statusBrowser" class="badge badge-pending">Pendiente</span>
      </div>
      <pre id="logBrowser"></pre>
    </div>

    <!-- 2. Permisos y c√°mara/micr√≥fono -->
    <div class="section">
      <div class="status-line">
        <h2>getUserMedia (c√°mara/micr√≥fono)</h2>
        <span id="statusMedia" class="badge badge-pending">Pendiente</span>
      </div>
      <pre id="logMedia"></pre>
    </div>

    <!-- 3. API /ice -->
    <div class="section">
      <div class="status-line">
        <h2>API ICE (/ice)</h2>
        <span id="statusIce" class="badge badge-pending">Pendiente</span>
      </div>
      <pre id="logIce"></pre>
    </div>

    <!-- 4. ICE / RTCPeerConnection -->
    <div class="section">
      <div class="status-line">
        <h2>ICE / RTCPeerConnection</h2>
        <span id="statusRtc" class="badge badge-pending">Pendiente</span>
      </div>
      <pre id="logRtc"></pre>
    </div>

    <!-- 5. Socket.IO -->
    <div class="section">
      <div class="status-line">
        <h2>Socket.IO / Se√±alizaci√≥n</h2>
        <span id="statusSocket" class="badge badge-pending">Pendiente</span>
      </div>
      <pre id="logSocket"></pre>
    </div>

    <div class="section small">
      <strong>Resumen r√°pido:</strong><br />
      ‚Ä¢ Si <strong>Socket.IO falla</strong> ‚Üí problema de IIS / WebSocket / reverse proxy.<br />
      ‚Ä¢ Si <strong>RTC falla pero Socket.IO pasa</strong> ‚Üí problema de ICE / STUN / TURN / firewall / NAT.<br />
      ‚Ä¢ Si <strong>getUserMedia falla</strong> ‚Üí permisos de c√°mara/micr√≥fono o navegador no soportado.
    </div>
  </div>

  <script>
    // Utilidades de UI -----------------------------------------------
    function setStatus(id, ok, msg) {
      const el = document.getElementById(id);
      el.textContent = msg || (ok ? "OK" : "ERROR");
      el.className = "badge " + (ok ? "badge-ok" : "badge-fail");
    }
    function setPending(id, msg) {
      const el = document.getElementById(id);
      el.textContent = msg || "Pendiente";
      el.className = "badge badge-pending";
    }
    function logTo(id, ...args) {
      const el = document.getElementById(id);
      const line = args.map(a => {
        if (a instanceof Error) return a.stack || a.message;
        if (typeof a === "object") return JSON.stringify(a, null, 2);
        return String(a);
      }).join(" ");
      el.textContent += line + "\\n";
    }
    function clearAllLogs() {
      ["logBrowser", "logMedia", "logIce", "logRtc", "logSocket"].forEach(id => {
        document.getElementById(id).textContent = "";
      });
      ["statusBrowser", "statusMedia", "statusIce", "statusRtc", "statusSocket"].forEach(id => {
        setPending(id, "Pendiente");
      });
    }

    // CONFIG basado en el host actual -------------------------------
    const CONFIG = {
      API_BASE: window.location.origin,         // https://192.168.0.251
      SIGNAL_URL: window.location.origin        // mismo host para Socket.IO
    };

    // 1. Diagn√≥stico del navegador / HTTPS --------------------------
    function testBrowser() {
      return new Promise((resolve) => {
        const id = "logBrowser";
        logTo(id, "User-Agent:", navigator.userAgent);
        logTo(id, "Location:", window.location.href);
        logTo(id, "Secure Context:", window.isSecureContext);
        logTo(id, "MediaDevices:", !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia));

        let ok = true;
        if (!window.isSecureContext) {
          ok = false;
          logTo(id, "‚ö† Este contexto NO es seguro (no es HTTPS ni localhost). Algunos navegadores bloquean c√°mara/micr√≥fono.");
        }
        if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) {
          ok = false;
          logTo(id, "‚ùå Este navegador no soporta getUserMedia correctamente.");
        }

        setStatus("statusBrowser", ok, ok ? "OK" : "Revisar");
        resolve(ok);
      });
    }

    // 2. getUserMedia -----------------------------------------------
    async function testMedia() {
      const id = "logMedia";
      try {
        logTo(id, "Solicitando permisos de c√°mara/micr√≥fono...");
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true,
          video: { width: 640, height: 480 }
        });
        const tracks = stream.getTracks().map(t => t.kind);
        logTo(id, "‚úî Permisos concedidos. Tracks:", tracks);
        stream.getTracks().forEach(t => t.stop());
        setStatus("statusMedia", true, "OK");
        return true;
      } catch (err) {
        logTo(id, "‚ùå Error en getUserMedia:", err);
        setStatus("statusMedia", false, "ERROR");
        return false;
      }
    }

    // 3. Probar API /ice --------------------------------------------
    async function testIceApi() {
      const id = "logIce";
      const url = CONFIG.API_BASE + "/ice";
      try {
        logTo(id, "Haciendo GET a", url, "...");
        const resp = await fetch(url, { credentials: "include" });
        logTo(id, "HTTP status:", resp.status);
        if (!resp.ok) {
          setStatus("statusIce", false, "HTTP " + resp.status);
          logTo(id, "‚ùå Respuesta no OK de /ice");
          return null;
        }
        const json = await resp.json();
        logTo(id, "Respuesta JSON:", json);
        if (!json.iceServers || !Array.isArray(json.iceServers)) {
          setStatus("statusIce", false, "Formato inv√°lido");
          logTo(id, "‚ùå No se encontr√≥ iceServers en la respuesta.");
          return null;
        }
        setStatus("statusIce", true, "OK");
        return json.iceServers;
      } catch (err) {
        logTo(id, "‚ùå Error llamando a /ice:", err);
        setStatus("statusIce", false, "ERROR");
        return null;
      }
    }

    // Helper: clasificar tipo de candidato ICE ----------------------
    function getCandidateType(cand) {
      if (!cand) return "unknown";
      const c = cand.candidate || String(cand);
      if (c.includes(" typ host")) return "host";
      if (c.includes(" typ srflx")) return "srflx";
      if (c.includes(" typ relay")) return "relay";
      return "other";
    }

    // 4. Probar RTCPeerConnection + ICE -----------------------------
    async function testRtc(iceServers) {
      const id = "logRtc";
      if (!iceServers) {
        logTo(id, "Sin iceServers, se usa [] (solo host candidates).");
        iceServers = [];
      }
      logTo(id, "Creando RTCPeerConnection con iceServers:", iceServers);

      const pc = new RTCPeerConnection({
        iceServers: [
          {
            urls: [
              "turn:192.168.0.251:3478?transport=udp",
              "turn:192.168.0.251:3478?transport=tcp"
            ],
            username: "videocall",
            credential: "supersecret"
          }
        ],
        iceTransportPolicy: "relay", // üî• clave para probar TURN
      });
      const stats = { host: 0, srflx: 0, relay: 0, other: 0 };
      let done = false;

      pc.onicecandidate = (ev) => {
        if (!ev.candidate) {
          logTo(id, "Fin de candidatos ICE (onicecandidate: null).");
          return;
        }
        const typ = getCandidateType(ev.candidate);
        stats[typ] = (stats[typ] || 0) + 1;
        logTo(id, "Candidato ICE local:", ev.candidate.candidate);
      };

      pc.oniceconnectionstatechange = () => {
        logTo(id, "iceConnectionState:", pc.iceConnectionState);
      };

      try {
        // Creamos un datachannel para forzar ICE aunque no haya media
        pc.createDataChannel("diag");
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        logTo(id, "Offer creada. Esperando candidatos durante ~3s...");
        await new Promise(res => setTimeout(res, 3000));
        done = true;

        logTo(id, "Resumen tipos de candidatos:", stats);

        // Regla r√°pida:
        // - host solamente => funcionar√° solo en redes sencillas / sin NAT estricto
        // - srflx -> STUN OK
        // - relay -> TURN OK (ideal para internet / redes duras)
        const tieneAlgo = Object.values(stats).some(v => v > 0);
        if (!tieneAlgo) {
          setStatus("statusRtc", false, "Sin candidatos");
          logTo(id, "‚ùå No se gener√≥ ning√∫n candidato ICE. Posible bloqueo de WebRTC.");
          return false;
        }

        if (stats.relay > 0) {
          setStatus("statusRtc", true, "OK (TURN)");
        } else if (stats.srflx > 0) {
          setStatus("statusRtc", true, "OK (STUN)");
        } else {
          setStatus("statusRtc", true, "Solo host");
          logTo(id, "‚ö† Solo candidatos 'host'. En redes con NAT / firewall puede fallar la llamada real.");
        }

        pc.close();
        return true;
      } catch (err) {
        if (!done) {
          logTo(id, "‚ùå Error en RTCPeerConnection:", err);
          setStatus("statusRtc", false, "ERROR");
        }
        try { pc.close(); } catch (_) {}
        return false;
      }
    }

    // 5. Probar Socket.IO -------------------------------------------
    function testSocket() {
      const id = "logSocket";
      return new Promise((resolve) => {
        const url = CONFIG.SIGNAL_URL;
        logTo(id, "Conectando Socket.IO a", url, "path=/socket.io ...");

        const socket = io(url, {
          path: '/socket.io',
          transports: ['polling'],
          upgrade: false,
          timeout: 8000,
          reconnectionAttempts: 1
        });

        let finished = false;

        socket.on("connect", () => {
          finished = true;
          logTo(id, "‚úî Conectado. sid:", socket.id);
          setStatus("statusSocket", true, "OK");
          socket.disconnect();
          resolve(true);
        });

        socket.on("connect_error", (err) => {
          if (finished) return;
          finished = true;
          logTo(id, "‚ùå connect_error:", err);
          setStatus("statusSocket", false, "ERROR");
          try { socket.disconnect(); } catch (_) {}
          resolve(false);
        });

        socket.on("error", (err) => {
          logTo(id, "Socket error:", err);
        });

        setTimeout(() => {
          if (!finished) {
            finished = true;
            logTo(id, "‚è± Timeout esperando conexi√≥n Socket.IO.");
            setStatus("statusSocket", false, "Timeout");
            try { socket.disconnect(); } catch (_) {}
            resolve(false);
          }
        }, 10000);
      });
    }

    // Orquestador del diagn√≥stico -----------------------------------
    async function runDiagnostics() {
      const btnRun = document.getElementById("btnRun");
      btnRun.disabled = true;
      clearAllLogs();

      logTo("logBrowser", "== Iniciando diagn√≥stico ==");
      const okBrowser = await testBrowser();

      if (!okBrowser) {
        logTo("logBrowser", "‚ö† Hay problemas con el navegador/HTTPS, pero seguimos con el resto para m√°s info.");
      }

      await testMedia();
      const iceServers = await testIceApi();
      await testRtc(iceServers);
      await testSocket();

      logTo("logBrowser", "== Diagn√≥stico terminado ==");
      btnRun.disabled = false;
    }

    // Eventos de botones --------------------------------------------
    document.getElementById("btnRun").addEventListener("click", runDiagnostics);
    document.getElementById("btnClear").addEventListener("click", clearAllLogs);
  </script>
</body>
</html>
